#ifndef PARSER_HPP
#define PARSER_HPP

#pragma once

#include "scanner.hpp"
#include "parseritems.hpp"
#include "ast.hpp"
#include "runutils.hpp"

using std::cout, std::cerr, std::string, std::vector, std::make_pair;

class Parser {
    public:
        Parser(Scanner* scptr) {
            sc = scptr;
            root = new ast_rt();
            prime_table();
        }

        // push into the prediction stack
        void ppush(ParserItem* p) {pred_stack.push_back(p);}
        // pop ParserItem from the prediction stack
        ParserItem* ppop() {ParserItem *p = pred_stack.back(); pred_stack.pop_back(); return p;}
        // print prediction stack
        void pprint() {
            if (!pred_stack.empty()) {
                for (int k = pred_stack.size() - 1; k >= 0; --k) {
                    cout << "name: " << tokname(pred_stack[k]->name())
                        << ", type: " << pred_stack[k]->type() 
                        << std::endl;
                }
                cout << std::endl;
            }
        }
        // push into the ast stack
        int apush(ast a) {
            true_res_stack.push_back(a);
            res_stack.push_back(true_res_stack.size()-1);
            return true_res_stack.size()-1;
        }
        void arepush(int index) {
            res_stack.push_back(index);
        }
        // pop ast from the ast stack
        int apop() {int a = res_stack.back(); res_stack.pop_back(); return a;}
        // get ast from the ast stack
        ast* aget(int index) {return &true_res_stack[index];}
        // print ast stack
        void aprint() {
            if (!res_stack.empty()) {
                for (int k = res_stack.size() - 1; k >= 0; --k) {
                    if (aget(k)->get_tok() >= 0) {
                        string nom = tokname(aget(k)->get_tok());
                        cout << "val[" << k << "]: " 
                             << aget(k)->get_type() 
                             << ((aget(k)->get_type() == "lit") 
                                ? string(", tok: ") + tokname(aget(k)->get_tok()) : "")
                             << std::endl;
                    } else cout << "aprint: empty stmt\n";
                }
                cout << std::endl;
            }
        }
        // check if object is a terminal or non-terminal
        bool is_terminal(Tokens t) {return t < P_START;}
        // parser warning
        void parse_warn(const char* ch) {cerr << "parser: " << ch << " at line " << sc->getlineno() << std::endl;}
        // general parser error
        void parse_err(const char* ch) {parse_warn(ch); exit(-1);}
        // unexpected terminal error (special case)
        void parse_unexpected_terminal_err(Tokens t_exp, Tokens t_rec) {
            string ch = "expected " + string(tokname(t_exp)) + ", got " + string(tokname(t_rec)) + "(" + sc->getlexeme() + ")";
            parse_err(ch.c_str());
        }
        void parse_illegal_transition_err(Tokens t_tos, Tokens t_cur) {
            string ch = "cannot transitiion from " + string(tokname(t_tos)) + " with input " + string(tokname(t_cur));
            parse_err(ch.c_str());
        }
        
        void print_root() {
            if (root == nullptr) {
                parse_err("cannot view root before parsing\n");
            } else root->print();
        }
        ast_rt* getroot() {return root;}

        int prime_table() {
            dict[make_pair<Tokens, Tokens>(P_START, ENDFILE)] = new vector<Tokens>({});
            dict[make_pair<Tokens, Tokens>(P_START, RULE)] = new vector<Tokens>({P_RULE, P_START});
            dict[make_pair<Tokens, Tokens>(P_START, BREAK)] = new vector<Tokens>({P_RULE, P_START});
            dict[make_pair<Tokens, Tokens>(P_RULE, RULE)] = new vector<Tokens>({RULE, ARROW, P_RULES, BREAK});
            dict[make_pair<Tokens, Tokens>(P_RULE, BREAK)] = new vector<Tokens>({BREAK});
            dict[make_pair<Tokens, Tokens>(P_RULES, EMPTY)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES, RULE)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES, TOK)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES, LOPT)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES, LREP)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, EMPTY)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, RULE)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, TOK)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, LOPT)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, LREP)] = new vector<Tokens>({P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, BAR)] = new vector<Tokens>({BAR, P_RULES_EL, P_RULES1});
            dict[make_pair<Tokens, Tokens>(P_RULES1, ROPT)] = new vector<Tokens>({});
            dict[make_pair<Tokens, Tokens>(P_RULES1, RREP)] = new vector<Tokens>({});
            dict[make_pair<Tokens, Tokens>(P_RULES1, BREAK)] = new vector<Tokens>({});
            dict[make_pair<Tokens, Tokens>(P_RULES_EL, EMPTY)] = new vector<Tokens>({EMPTY});
            dict[make_pair<Tokens, Tokens>(P_RULES_EL, RULE)] = new vector<Tokens>({RULE});
            dict[make_pair<Tokens, Tokens>(P_RULES_EL, TOK)] = new vector<Tokens>({TOK});
            dict[make_pair<Tokens, Tokens>(P_RULES_EL, LOPT)] = new vector<Tokens>({LOPT, P_RULES, ROPT});
            dict[make_pair<Tokens, Tokens>(P_RULES_EL, LREP)] = new vector<Tokens>({LREP, P_RULES, RREP});
            return EXIT_SUCCESS;
        }

        void print_dict() {
            ParseDict::iterator it;
            for (it = dict.begin(); it != dict.end(); ++it) {
                cout << "(" << it->first.first << ", "
                     << it->first.second << ": [";
                for (auto x : *(it->second)) {
                    cout << x << ", ";
                } cout << "]\n";
            }
        }

        int parse() {
            ppush(new ParserTok(ENDFILE));
            ppush(new ParserRule(P_START));

            ParserItem *tos;
            int cur = sc->lex();
            if (flags.SCANNER_TRACE)
                cout << "first symbol: " 
                     << tokname(cur) 
                     << std::endl;
            while (!pred_stack.empty()) {
                if (flags.PARSER_TRACE) 
                    pprint();
                tos = pred_stack.back();
                if (tos->type() == "reduce") {
                    ParserRed *mytos = (ParserRed*)tos;
                    tos = ppop();
                    int len = mytos->getarg_count();
                    
                    int head;
                    vector<int> tail;
                    for (int i = 0; i < len; i++) {
                        tail.push_back(apop());
                        cout << tail.back() << std::endl;
                    }

                    switch(mytos->name()) {
                        case Tokens::P_START: {
                            cout << "wa dhinikum1\n";
                            if (len == 0)
                                apush(ast_rt());
                            else {
                                auto t1 = aget(tail[1]);
                                auto t0 = aget(tail[0]);
                                if (t1->get_tok() > -1)
                                    t0->add(t1);
                                arepush(tail[0]);
                            } break;
                        }
                        
                        case Tokens::P_RULE: {
                            cout << "wa dhinikum2\n";
                            if (len == 1)
                                apush(ast());
                            else {
                                auto t3 = aget(tail[3]);
                                auto t1 = aget(tail[1]);
                                vector<ast*> lst;
                                ast_el* root = (ast_el*)t1;
                                while (root != nullptr) {
                                    lst.push_back(root);
                                    root = (ast_el*)root->get_nxt();
                                } apush(ast_rule(t3, lst));
                            } break;
                        }
                        
                        case Tokens::P_RULES: {
                            cout << "wa dhinikum3\n";
                            auto t0 = aget(tail[0]);
                            auto t1 = aget(tail[1]);
                            if (t0->get_type() == "or-stmt") {
                                ast_or *myr = (ast_or*)((ast_el*)t0)->get_ast();
                                myr->setleft(t1);
                                arepush(tail[0]);
                            }
                            else
                            if (t0->get_tok() == -1) {
                                arepush(tail[1]);
                            }
                            else {
                                ast_el *myr = (ast_el*)t1;
                                myr->addnext(t0);
                                arepush(tail[1]);
                            } break;
                            cout << "wa dhinikum\n";
                        }
                        
                        case Tokens::P_RULES1: {
                            cout << "wa dhinikum4\n";
                            auto t0 = aget(tail[0]);
                            auto t1 = aget(tail[1]);
                            cout << "wa dhinikum\n";
                            if (len == 0)
                               apush(ast());
                            else
                            if (len == 3) {
                                cout << "wa dhinikum\n";
                                if (t0->get_type() == "or-stmt") {
                                    ast_or *myr = (ast_or*)((ast_el*)t0)->get_ast();
                                    myr->setleft(t1);
                                    auto x = apush(ast_or(t0));
                                    apush(ast_el(new ast_or(myr)));
                                }
                                else {
                                    ast_el *myr = (ast_el*)t1;
                                    myr->addnext(t0);
                                    apush(ast_el(new ast_or(myr)));
                                }
                            } 
                            else 
                            if (len == 2) {
                                cout << "wa dhinikum\n";
                                if (t0->get_type() == "or-stmt") {
                                    ast_or *myr = (ast_or*)((ast_el*)t0)->get_ast();
                                    myr->setleft(t1);
                                    arepush(tail[0]);
                                }
                                else {
                                    ast_el *myr = (ast_el*)t1;
                                    myr->addnext(t0);
                                    arepush(tail[1]);
                                }
                            } break;
                        }
                        
                        case Tokens::P_RULES_EL: {
                            cout << "wa dhinikum5\n";
                            auto t0 = aget(tail[0]);
                            auto t1 = aget(tail[1]);
                            if (len == 1)
                                apush(ast_el(t0));
                            else {
                                ast_el *myop = (ast_el*)t1;
                                auto x = apush(ast_in(myop, (Tokens)t0->get_tok()));
                                apush(ast_el(aget(x)));
                            } 
                            break;
                        }

                        default: 
                            parse_err("invalid reduce symbol");
                    }
                    
                    if (flags.PARSER_TRACE)
                        aprint();
                }

                else
                if (tos->type() == "nonterm") {
                    ParsePair x = make_pair<Tokens, Tokens>((Tokens)tos->name(), (Tokens)cur);
                    if (dict.count(x) == 0)
                        parse_illegal_transition_err((Tokens)tos->name(), (Tokens)cur);
                    else {
                        tos = ppop();
                        auto x = dict[make_pair<Tokens, Tokens>((Tokens)tos->name(), (Tokens)cur)];
                        int len = x->size();
                        ppush(new ParserRed(tos->name(), len));
                        if (len > 0)
                            for (int i = len - 1; i >= 0; i--)
                                if (is_terminal((*x)[i])) ppush(new ParserTok((*x)[i])); else ppush(new ParserRule((*x)[i]));
                        free(tos);         
                    }
                }

                else {
                    if (tos->name() == cur) {
                        tos = ppop();
                        if (cur != Tokens::ENDFILE) {
                            if (tos->type() == "empty")
                                apush(ast_empty());
                            else apush(lit(cur, sc->getlexeme()));
                            if (flags.PARSER_TRACE)
                                aprint();
                        }
                        cur = sc->lex();
                        if (flags.SCANNER_TRACE)
                            cout << "next symbol: " 
                                 << tokname(cur) 
                                 << std::endl;
                        free(tos);
                    } else parse_unexpected_terminal_err((Tokens)tos->name(), (Tokens)cur);
                }
            }
            
            root = (ast_rt*)&true_res_stack[res_stack[0]];
            return EXIT_SUCCESS;
        }


    private:
        Scanner *sc;
        ParseDict dict;
        vector<int> res_stack;
        vector<ast> true_res_stack;
        vector<ParserItem*> pred_stack;
        ast_rt *root = nullptr;

};

#endif