LPAR       \(
RPAR       \)
LBRACE     \{
RBRACE     \}

ID  [A-Za-z][A-Za-z0-9]* {
    IF if
    FOR for
    ELSE else
    RETURN return
    BREAK break
    IN in
}
INT        [0-9]+
STRING     "([\w!#-&\(-\[\]-\}]|\\[tnr"'])*"
PLUS       \+
MINUS      \-
MULT       \*
DIV        /
MOD        %
COMMA      ,
ASSIGN     =
AND        and|&&
OR         or|\|\|
NEG        not|~
EQ         is|==
NEQ        ~=
GEQ        >=
GT         >
LEQ        <=
LT         <
BREAK      ;
ELLIPSIS   \.\.\.

%%
%ignore \w
%ignore \t
%ignore \n
%nodecollapse

%start Start

Start => { TopLevelDecl } ;
TopLevelDecl => VarDecl BREAK | FuncDecl ;

VarDecl => Type Name ;
Name => ID ;
Type => ID ;

FuncDecl => Type Name Args Block ;
Args => LPAR [ ArgDecl { COMMA ArgDecl } ] RPAR ;
ArgDecl => Type Name ;

Block => LBRACE { Statement BREAK } RBRACE ;

Statement => VarDecl | SimpleStmt | ReturnStmt | BreakStmt | IfStmt | ForStmt ;

SimpleStmt => EmptyStmt | Expression | Assignment ;
EmptyStmt => empty ;

Expression => CompExpr { BoolOp Expression } ;
CompExpr => MultExpr { CompOp CompExpr } ;
MultExpr => AddExpr { MultOp MultExpr } ;
AddExpr => UnaryExpr { AddOp AddExpr } ;

UnaryExpr => PrimaryExpr | UnaryOp UnaryExpr ;

PrimaryExpr => FuncCall | Operand ;
FuncCall => Name LPAR ExpressionList RPAR ;

ExpressionList => [ Expression { COMMA Expression } ] ;

Operand => Literal | Name | LPAR Expression RPAR ;
Literal => INT | STRING | List ;
List => LBRACE ListExpr RBRACE ;
ListExpr => ExpressionList | Expression ELLIPSIS [ Expression ] ;

UnaryOp => MINUS | NEG ;
AddOp => PLUS | MINUS ;
MultOp => MULT | DIV | MOD ;
CompOp => NEG | GEQ | GT | LEQ | LT | IN ;
BoolOp => AND | OR ;

Assignment => Expression ASSIGN Expression ;

ReturnStmt => RETURN [ Expression ] ;

BreakStmt => BREAK ;

IfStmt => IF Expression Block [ ELSE IfStmt | ELSE Block ] ;

ForStmt => FOR Expression Block ;