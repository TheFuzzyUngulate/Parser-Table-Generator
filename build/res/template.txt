#ifndef PTGPARSE_H
#define PTGPARSE_H
#pragma once

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct
m_stack
{
    int    count;
    size_t size;
    void*  content;
    int    capacity;
}
m_stack;
#define m_stack_tos(stack) (stack.content + (stack.size * (stack.count - 1)))

m_stack
_m_stack_init(size_t size)
{
    m_stack m;

    m.count    = 0;
    m.size     = size;
    m.capacity = 2;
    m.content  = malloc(m.capacity * m.size);

    return m;
}

#define m_stack_init(t) (_m_stack_init(sizeof(t)))

void m_stack_push(m_stack* m, void* item)
{
    if (m->count == m->capacity) {
        m->capacity = m->capacity * 3 / 2;
        m->content  = realloc(m->content, m->capacity * m->size);
    }
    memcpy(m->content + m->count, item, m->size);
    m->count++;
}

void* m_stack_pop(m_stack* m)
{
    if (m->count > 0) {
        void* item = malloc(m->size);
        memcpy(item, m->content + (m->count - 1), m->size);
        return item;
    } else return NULL;
}

/* stop */

static FILE* ptg_in            = NULL;
static int ptg_line            = 0;
static FILE* ptg_out           = NULL;
static int ptg_column          = 0;
static int ptg_unlex_count     = 0;
static ptg_enum* ptg_unlex_buf = NULL;
static int ptg_ungetch_count   = 0;
static char* ptg_ungetch_buf   = NULL;
static char* ptg_lexeme        = NULL;
static char ptg_lexeme_count   = 0;

char
ptg_getch()
{
    char ch;

    if (ptg_ungetch_buf && ptg_ungetch_count > 0)
    {
        --ptg_ungetch_count;
        ch = ptg_ungetch_buf[ptg_ungetch_count];
        ptg_ungetch_buf = (char*)realloc(ptg_ungetch_buf, ptg_ungetch_count * sizeof(char));
        return ch;
    }

    return getc(ptg_in);
}

void
ptg_ungetch(char ch)
{
    ++ptg_ungetch_count;
    ptg_ungetch_buf = (char*)realloc(ptg_ungetch_buf, ptg_ungetch_count * sizeof(char));
    ptg_ungetch_buf[ptg_ungetch_count-1] = ch;
}

void
ptg_unlex(ptg_enum tok)
{
    ++ptg_unlex_count;
    ptg_unlex_buf = (ptg_enum*)realloc(ptg_unlex_buf, ptg_unlex_count * sizeof(ptg_enum));
    ptg_unlex_buf[ptg_unlex_count-1] = tok;
}

char*
ptg_getlexeme()
{
    int len   = strlen(ptg_lexeme);
    char* res = (char*)malloc((len + 1) * sizeof(char));
    memcpy(res, ptg_lexeme, (len + 1) * sizeof(char));
    return res;
}

ptg_enum
ptg_lex()
{
    int ch;
    int stat;

    stat = 0;

    if (!ptg_in) 
        ptg_in = stdin;
    if (!ptg_out) 
        ptg_out = stdout;
    
    if (ptg_lexeme) 
        free(ptg_lexeme);
    
    ptg_lexeme_count = 1;
    ptg_lexeme = (char*)malloc(2 * sizeof(char));
    ptg_lexeme[0] = ptg_getch();
    ptg_lexeme[1] = '\0';

    while (1)
    {
/* stop */
        ch = ptg_getch();
        if (ch == EOF) return P_TOK_END;
        
        ptg_lexeme_count++;
        ptg_lexeme = (char*)realloc(ptg_lexeme, (ptg_lexeme_count + 1) * sizeof(char));
        ptg_lexeme[ptg_lexeme_count]   = '\0';
        ptg_lexeme[ptg_lexeme_count-1] = ptg_getch();
    }
}

/* stop */

typedef struct 
ptg_pdata
{
    int name;
    int state;
    int funcindex;
    int size;
}
ptg_pdata_t;

#define PTG_GOTO   1
#define PTG_ERROR  0
#define PTG_SHIFT  2
#define PTG_REDUCE 3
#define PTG_ACCEPT 4

static ptg_pdata_t *ptg_ptable = NULL;

#define ptg_table_next(state, token) (*(ptg_ptable + ((state) * P_ELEMENT_COUNT) + (token)))

static inline void
ptg_ptable_init()
{
    ptg_ptable = (ptg_pdata_t*)calloc(P_STATE_COUNT * P_ELEMENT_COUNT, sizeof(ptg_pdata_t));

/* stop */
}

typedef struct
ptg_node
{
    char* name;
    ptg_enum tok;
    int ccount;
    int ccapacity;
    struct ptg_node **children;
}
ptg_node_t;

ptg_node_t*
ptg_node_new(char* name, ptg_enum tok)
{
    ptg_node_t* node = (ptg_node_t*)malloc(sizeof(ptg_node_t));

    node->name      = name;
    node->ccount    = 0;
    node->tok       = tok;
    node->ccapacity = 2;
    node->children  = (ptg_node_t**)malloc(node->ccapacity * sizeof(ptg_node_t*));

    return node;
}

void ptg_node_addchild(ptg_node_t* node, ptg_node_t* child)
{
    if (node->ccount == node->ccapacity) {
        node->ccapacity = node->ccapacity * 3 / 2;
        node->children  = (ptg_node_t**)realloc(node->children, node->ccapacity * sizeof(ptg_node_t*));
    }

    node->children[node->ccount] = child;
    node->ccount++;
}

void ptg_node_print(ptg_node_t* node, int indent)
{
    int i;

    for (i = 0; i < indent; ++i) putchar(' ');
    printf("%s: %s\n", node->name, ptg_enum_string(node->tok));
    for (i = 0; i < node->ccount; ++i)
        ptg_node_print(node->children[i], indent+1);
}

ptg_node_t* ptg_parse()
{
    char a;
    int state;
    ptg_enum tos;
    m_stack nodes;
    m_stack states;
    m_stack symbols;
    ptg_pdata_t next;
    ptg_node_t *leaf;

    ptg_ptable_init();

    state   = 0;
    states  = m_stack_init(int);
    symbols = m_stack_init(ptg_enum);
    nodes   = m_stack_init(ptg_node_t*);
    
    m_stack_push(&states, &state);

    while (1)
    {
        tos   = ptg_lex();
        state = *(int*)m_stack_tos(states);
        next  = ptg_table_next(state, tos);

        switch (next.name)
        {
            case PTG_SHIFT:
                m_stack_push(&symbols, &tos);
                m_stack_push(&states, &(next.state));
                leaf = ptg_node_new(ptg_getlexeme(), tos);
                m_stack_push(&nodes, &leaf);
                break;

            case PTG_REDUCE:
                m_stack_pop(&states);
                leaf = ptg_node_new(NULL, tos);
                for (int i = 0; i < next.size; ++i) {
                    ptg_node_t** sub = (ptg_node_t**)m_stack_pop(&nodes);
                    if (sub == NULL) {
                        fprintf(stderr, "stack out of nodes.\n");
                        exit(EXIT_FAILURE);
                    }
                    ptg_node_addchild(leaf, *sub);
                }
                m_stack_push(&nodes, &leaf);
                m_stack_push(&states, &(next.state));
                break;

            case PTG_GOTO:
                m_stack_push(&states, &(next.state));
                break;

            case PTG_ACCEPT:
                leaf = *(ptg_node_t**)m_stack_pop(&nodes);
                return leaf;

            case PTG_ERROR:
                fprintf(stderr, "invalid token \"%s\".\n", ptg_enum_string(tos));
                exit(EXIT_FAILURE);
        }
    }
}

#undef ptg_table_next

#endif