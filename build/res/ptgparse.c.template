#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
/* stop */

typedef struct
m_stack
{
    int    count;
    size_t size;
    void*  content;
    int    capacity;
}
m_stack;
#define m_stack_tos(stack) (stack.content + (stack.size * (stack.count - 1)))

m_stack
_m_stack_init(size_t size)
{
    m_stack m;

    m.count    = 0;
    m.size     = size;
    m.capacity = 2;
    m.content  = malloc(m.capacity * m.size);

    return m;
}

#define m_stack_init(t) (_m_stack_init(sizeof(t)))

void m_stack_push(m_stack* m, void* item)
{
    if (m->count == m->capacity) {
        m->capacity = m->capacity * 3 / 2;
        m->content  = realloc(m->content, m->capacity * m->size);
    }
    memcpy(m->content + m->count, item, m->size);
    m->count++;
}

void* m_stack_pop(m_stack* m)
{
    if (m->count > 0) {
        void* item = malloc(m->size);
        memcpy(item, m->content + (m->count - 1), m->size);
        return item;
    } else return NULL;
}

void m_stack_clear(m_stack* m)
{
    if (m->count > 0) {
        m->capacity = 2;
        m->count = 0;
        m->content = realloc(m->content, m->capacity * m->size);
    }
}

// static FILE* ptg_infile = NULL;

typedef struct
ptg_sc
{
    unsigned int line;     // current line number
    unsigned int column;   // current column number
    struct {
        m_stack  lexeme;   // current lexeme
        m_stack  chbuf;    // unget buffer
        m_stack  tokbuf;   // unlex buffer
        ptg_enum lasttok;  // last token returned by lex
    } prog;
    struct {
        m_stack seeks;     // saved positions for seek
        m_stack answers;   // saved answers for answer checking
        m_stack counters;  // saved counters for future updates
    } check;
}
ptg_sc;

static ptg_sc* sc = NULL;

char scan() {
    char ch;
    if (sc->prog.chbuf.count > 0) {
        ch = *(char*)m_stack_pop(&(sc->prog.chbuf));
    } else {
        ch = fgetc(ptg_infile);
        if (ch == EOF) 
            return EOF;
    }
    m_stack_push(&(sc->prog.lexeme), &ch);
    return ch;
}

void save_pos() {
    int tl = ftell(ptg_infile);
    m_stack_push(&(sc->check.seeks), &tl);
}

char load_pos() {
    if (sc->check.seeks.count > 0) {
        int p  = *(int*)m_stack_pop(&(sc->check.seeks));
        int fs = fseek( ptg_infile, p, SEEK_SET );
        if (!fs) {
            fprintf(stderr, "error: fseek failed.\n");
            exit(EXIT_FAILURE);
        }
        return scan();
    } else {
        fprintf(stderr, "error: no seek positions have been saved.\n");
        exit(EXIT_FAILURE);
    }
}

char unscan(char ch) {
    m_stack_push(&(sc->prog.chbuf), &ch);
}

void save_bool(bool q) {
    m_stack_push(&(sc->check.answers), &q);
}

bool load_bool() {
    if (sc->check.answers.count > 0) {
        return *(bool*)m_stack_pop(&(sc->check.answers));
    } else {
        fprintf(stderr, "error: no answers have been saved.\n");
        exit(EXIT_FAILURE);
    }
}

void new_counter() {
    int q = 0;
    m_stack_push(&(sc->check.counters), &q);
}

int count() {
    if (sc->check.counters.count > 0) {
        return *(int*)m_stack_pop(&(sc->check.counters));
    } else {
        fprintf(stderr, "error: no counters have been saved.\n");
        exit(EXIT_FAILURE);
    }
}

int inc_counter() {
    if (sc->check.counters.count > 0) {
        ++(*(int*)m_stack_tos(sc->check.counters));
    } else {
        fprintf(stderr, "error: no counters have been saved.\n");
        exit(EXIT_FAILURE);
    }
}

#define ptg_tokret(val) do {\
    sc->prog.lasttok = (val);\
    return (val);\
} while(0);

char* ptg_lexeme() {
    char* res = (char*)malloc((sc->prog.lexeme.count + 1) * sizeof(char));
    memcpy(res, sc->prog.lexeme.content, sc->prog.lexeme.count * sizeof(char));
    res[sc->prog.lexeme.count] = '\0';
    return res;
}

ptg_enum
ptg_lex()
{
    int ch;
    if (sc == NULL)
    {
        sc = (ptg_sc*)malloc(sizeof(ptg_sc));

        sc->line   = 0;
        sc->column = 0;

        sc->prog.lexeme = m_stack_init(char);
        sc->prog.chbuf  = m_stack_init(char);
        sc->prog.tokbuf = m_stack_init(ptg_enum);

        sc->check.seeks    = m_stack_init(int);
        sc->check.answers  = m_stack_init(bool);
        sc->check.counters = m_stack_init(int);
    }

    if (sc->prog.lexeme.count > 0) {
        m_stack_clear(&(sc->prog.lexeme));
    }

    if (sc->prog.tokbuf.count > 0) {
        ptg_enum tok = *(ptg_enum*)m_stack_pop(&(sc->prog.tokbuf));
        return tok;
    }

    while (1)
    {
/* stop */
    }
}

void ptg_unlex(ptg_enum tok) {
    m_stack_push(&(sc->prog.tokbuf), &tok);
}

/* stop */

#define PTG_GOTO   1
#define PTG_ERROR  0
#define PTG_SHIFT  2
#define PTG_REDUCE 3
#define PTG_ACCEPT 4

typedef struct ptg_pdata {
    int action;
    union { 
        int shift;
        int sgoto;
        char accept;
        char error;
        struct { 
            int rule;
            int count;
            ptg_enum lhs_tok;
        } reduce; 
    } op;
} ptg_pdata_t;

static ptg_pdata_t *ptg_ptable = NULL;

#define ptg_table_next(state, token) (*(ptg_ptable + ((state) * P_ELEMENT_COUNT) + (token)))

static inline void
ptg_table_set(int state, ptg_enum token, ptg_pdata_t data)
{
    ptg_pdata_t old = ptg_table_next(state, token);
    if (old.action != PTG_ERROR) {
        if (old.action == PTG_SHIFT && data.action == PTG_REDUCE) {
            fprintf(stderr, stderr, "warning: shift-reduce conflict at (state#%d, %s)\n", state, ptg_enum_string(token));
            fprintf(stderr, stderr, "opting to shift...\n");
            return;
        }
        if (old.action == PTG_REDUCE && data.action == PTG_SHIFT) {
            fprintf(stderr, stderr, "warning: shift-reduce conflict at (state#%d, %s)\n", state, ptg_enum_string(token));
            fprintf(stderr, stderr, "opting to shift...\n");
        }
        if (old.action == PTG_REDUCE && data.action == PTG_REDUCE) {
            fprintf(stderr, stderr, "error: reduce-reduce conflict at (state#%d, %s)\n", state, ptg_enum_string(token));
            exit(EXIT_FAILURE);
        }
    }

    ptg_table_next(state, token) = data;
}

static inline void
ptg_ptable_init()
{
    ptg_ptable = (ptg_pdata_t*)calloc(P_STATE_COUNT * P_ELEMENT_COUNT, sizeof(ptg_pdata_t));

/* stop */
}

typedef struct
ptg_node
{
    char* name;
    ptg_enum tok;
    int ccount;
    int ccapacity;
    struct ptg_node **children;
}
ptg_node_t;

ptg_node_t*
ptg_node_new(char* name, ptg_enum tok)
{
    ptg_node_t* node = (ptg_node_t*)malloc(sizeof(ptg_node_t));

    node->name      = name;
    node->ccount    = 0;
    node->tok       = tok;
    node->ccapacity = 2;
    node->children  = (ptg_node_t**)malloc(node->ccapacity * sizeof(ptg_node_t*));

    return node;
}

void ptg_node_addchild(ptg_node_t* node, ptg_node_t* child)
{
    if (node->ccount == node->ccapacity) {
        node->ccapacity = node->ccapacity * 3 / 2;
        node->children  = (ptg_node_t**)realloc(node->children, node->ccapacity * sizeof(ptg_node_t*));
    }

    node->children[node->ccount] = child;
    node->ccount++;
}

void ptg_node_print(ptg_node_t* node, int indent)
{
    int i;

    for (i = 0; i < indent; ++i) putchar(' ');
    printf("%s: %s\n", node->name, ptg_enum_string(node->tok));
    for (i = 0; i < node->ccount; ++i)
        ptg_node_print(node->children[i], indent+1);
}

ptg_node_t* ptg_parse()
{
    char a;
    int state;
    ptg_enum tos;
    m_stack nodes;
    m_stack states;
    m_stack symbols;
    ptg_pdata_t next;
    ptg_node_t *leaf;

    ptg_ptable_init();

    state   = 0;
    states  = m_stack_init(int);
    symbols = m_stack_init(ptg_enum);
    nodes   = m_stack_init(ptg_node_t*);
    
    m_stack_push(&states, &state);

    while (1)
    {
        tos   = ptg_lex();
        state = *(int*)m_stack_tos(states);
        next  = ptg_table_next(state, tos);

        switch (next.action)
        {
            case PTG_SHIFT:
                m_stack_push(&symbols, &tos);
                m_stack_push(&states, &(next.op.shift));
                leaf = ptg_node_new(ptg_getlexeme(), tos);
                m_stack_push(&nodes, &leaf);
                break;

            case PTG_REDUCE:
                m_stack_pop(&states);
                leaf = ptg_node_new(NULL, tos);
                for (int i = 0; i < next.op.reduce.count; ++i) {
                    ptg_node_t** sub = (ptg_node_t**)m_stack_pop(&nodes);
                    if (sub == NULL) {
                        fprintf(stderr, stderr, "stack out of nodes.\n");
                        exit(EXIT_FAILURE);
                    }
                    ptg_node_addchild(leaf, *sub);
                }
                m_stack_push(&nodes, &leaf);
                m_stack_push(&states, &(next.op.reduce.rule));
                break;

            case PTG_GOTO:
                m_stack_push(&states, &(next.op.sgoto));
                break;

            case PTG_ACCEPT:
                leaf = *(ptg_node_t**)m_stack_pop(&nodes);
                return leaf;

            case PTG_ERROR:
                fprintf(stderr, stderr, "invalid token \"%s\".\n", ptg_enum_string(tos));
                exit(EXIT_FAILURE);
        }
    }
}

#undef ptg_table_next